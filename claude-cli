#!/bin/bash

set -e

CLAUDE_API_URL="https://api.anthropic.com/v1/messages"
CONFIG_FILE="$HOME/.claude-cli-config"
DEFAULT_MODEL="claude-3-5-haiku-20241022"

show_help() {
    cat << EOF
Usage: claude-cli [OPTIONS] "your question"

A simple CLI tool for interacting with Anthropic Claude API.

OPTIONS:
    -h, --help      Show this help message
    -k, --key KEY   Set API key (saves to config file)
    -m, --model     Model to use (default: claude-3-5-haiku-20241022)
    --no-format     Disable markdown formatting in output

EXAMPLES:
    claude-cli "What is the weather like today?"
    claude-cli -k YOUR_API_KEY "Hello Claude"
    claude-cli -m claude-3-haiku-20240307 "Quick question"
    claude-cli --no-format "Show raw markdown output"

SETUP:
    1. Get your API key from https://console.anthropic.com/
    2. Run: claude-cli -k YOUR_API_KEY
    3. Ask questions: claude-cli "Your question here"
EOF
}

save_api_key() {
    echo "CLAUDE_API_KEY=$1" > "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
    echo "API key saved to $CONFIG_FILE"
    exit 0
}

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
    fi
}

format_markdown() {
    local text="$1"
    local no_format="$2"
    
    if [[ "$no_format" == "true" ]]; then
        echo "$text"
        return
    fi
    
    # Try to use glow if available for better markdown rendering
    if command -v glow &> /dev/null; then
        echo "$text" | glow -s auto -w 80
        return
    fi
    
    # Define colors using printf with ANSI codes for better compatibility
    local RED=$(printf '\033[31m')
    local GREEN=$(printf '\033[32m')
    local YELLOW=$(printf '\033[33m')
    local BLUE=$(printf '\033[34m')
    local MAGENTA=$(printf '\033[35m')
    local CYAN=$(printf '\033[36m')
    local WHITE=$(printf '\033[37m')
    local BOLD=$(printf '\033[1m')
    local DIM=$(printf '\033[2m')
    local ITALIC=$(printf '\033[3m')
    local UNDERLINE=$(printf '\033[4m')
    local RESET=$(printf '\033[0m')
    local BG_BLACK=$(printf '\033[40m')
    local BG_GRAY=$(printf '\033[100m')
    
    # Process text line by line to maintain structure
    echo "$text" | while IFS= read -r line || [[ -n "$line" ]]; do
        processed_line="$line"
        
        # Headers with different colors and styles
        if [[ $processed_line =~ ^####[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n" "$WHITE" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
        elif [[ $processed_line =~ ^###[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n" "$CYAN" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
        elif [[ $processed_line =~ ^##[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n" "$BLUE" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
        elif [[ $processed_line =~ ^#[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n\n" "$MAGENTA" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
            
        # Code blocks (triple backticks)
        elif [[ $processed_line =~ ^\`\`\`(.*)$ ]]; then
            if [[ -n "${BASH_REMATCH[1]}" ]]; then
                printf "%s%s┌─ %s ─%s\n" "$GREEN" "$DIM" "${BASH_REMATCH[1]}" "$RESET"
            else
                printf "%s%s└────────%s\n" "$GREEN" "$DIM" "$RESET"
            fi
            
        # Horizontal rule
        elif [[ $processed_line =~ ^---+$ ]] || [[ $processed_line =~ ^\*\*\*+$ ]]; then
            printf "%s%s────────────────────────────────────────%s\n" "$DIM" "$WHITE" "$RESET"
            
        # Blockquotes
        elif [[ $processed_line =~ ^\>[[:space:]]*(.*)$ ]]; then
            printf "%s%s▌ %s%s%s\n" "$YELLOW" "$DIM" "$ITALIC" "${BASH_REMATCH[1]}" "$RESET"
            
        # Lists (unordered)
        elif [[ $processed_line =~ ^([[:space:]]*)[-*+][[:space:]](.*)$ ]]; then
            local indent="${BASH_REMATCH[1]}"
            local content="${BASH_REMATCH[2]}"
            printf "%s%s•%s %s\n" "$indent" "$CYAN" "$RESET" "$content"
            
        # Lists (ordered)
        elif [[ $processed_line =~ ^[[:space:]]*[0-9]+\.[[:space:]](.*)$ ]]; then
            local indent=""
            local number=""
            if [[ $processed_line =~ ^([[:space:]]*)([0-9]+)\.[[:space:]](.*)$ ]]; then
                indent="${BASH_REMATCH[1]}"
                number="${BASH_REMATCH[2]}"
                content="${BASH_REMATCH[3]}"
                printf "%s%s%s%s.%s %s\n" "$indent" "$BLUE" "$BOLD" "$number" "$RESET" "$content"
            fi
            
        else
            # Process inline formatting
            
            # Bold text **text** and __text__
            processed_line=$(echo "$processed_line" | sed "s/\*\*\([^*]*\)\*\*/${BOLD}\1${RESET}/g")
            processed_line=$(echo "$processed_line" | sed "s/__\([^_]*\)__/${BOLD}\1${RESET}/g")
            
            # Italic text *text* and _text_ (avoid conflict with bold)
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)\*\([^*][^*]*\)\*\([^*_]\)/\1${ITALIC}\2${RESET}\3/g")
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)_\([^_][^_]*\)_\([^*_]\)/\1${ITALIC}\2${RESET}\3/g")
            processed_line=$(echo "$processed_line" | sed "s/^\*\([^*][^*]*\)\*\([^*_]\)/${ITALIC}\1${RESET}\2/g")
            processed_line=$(echo "$processed_line" | sed "s/^_\([^_][^_]*\)_\([^*_]\)/${ITALIC}\1${RESET}\2/g")
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)\*\([^*][^*]*\)\*$/${ITALIC}\2${RESET}/g")
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)_\([^_][^_]*\)_$/${ITALIC}\2${RESET}/g")
            
            # Strikethrough ~~text~~
            processed_line=$(echo "$processed_line" | sed "s/~~\([^~]*\)~~/${DIM}\1${RESET}/g")
            
            # Inline code `code`
            processed_line=$(echo "$processed_line" | sed "s/\`\([^\`]*\)\`/${BG_GRAY}${WHITE} \1 ${RESET}/g")
            
            # Links [text](url)
            processed_line=$(echo "$processed_line" | sed "s/\[\([^]]*\)\](\([^)]*\))/${UNDERLINE}${BLUE}\1${RESET}${DIM} (\2)${RESET}/g")
            
            # Simple URLs http(s)://...
            processed_line=$(echo "$processed_line" | sed "s/\(https\?:\/\/[^[:space:]]*\)/${UNDERLINE}${BLUE}\1${RESET}/g")
            
            printf "%s\n" "$processed_line"
        fi
    done
}

check_dependencies() {
    if ! command -v curl &> /dev/null; then
        echo "Error: curl is required but not installed." >&2
        exit 1
    fi
    
    if ! command -v jq &> /dev/null; then
        echo "Error: jq is required but not installed." >&2
        echo "Install with: brew install jq (macOS) or apt-get install jq (Ubuntu)" >&2
        exit 1
    fi
}

send_request() {
    local query="$1"
    local model="${2:-$DEFAULT_MODEL}"
    local no_format="$3"
    
    if [[ -z "$CLAUDE_API_KEY" ]]; then
        echo "Error: API key not found. Set it with: claude-cli -k YOUR_API_KEY" >&2
        exit 1
    fi
    
    local json_payload=$(jq -n \
        --arg model "$model" \
        --arg query "$query" \
        '{
            "model": $model,
            "max_tokens": 1024,
            "messages": [
                {
                    "role": "user",
                    "content": $query
                }
            ]
        }')
    
    local response=$(curl -s -X POST "$CLAUDE_API_URL" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $CLAUDE_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "$json_payload")
    
    if echo "$response" | jq -e '.error' &> /dev/null; then
        echo "Error: $(echo "$response" | jq -r '.error.message')" >&2
        exit 1
    fi
    
    local content=$(echo "$response" | jq -r '.content[0].text')
    format_markdown "$content" "$no_format"
}

main() {
    check_dependencies
    load_config
    
    local model="$DEFAULT_MODEL"
    local query=""
    local no_format="false"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -k|--key)
                if [[ -z "$2" ]]; then
                    echo "Error: API key required after -k/--key" >&2
                    exit 1
                fi
                save_api_key "$2"
                ;;
            -m|--model)
                if [[ -z "$2" ]]; then
                    echo "Error: Model name required after -m/--model" >&2
                    exit 1
                fi
                model="$2"
                shift 2
                ;;
            --no-format)
                no_format="true"
                shift
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                show_help >&2
                exit 1
                ;;
            *)
                query="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$query" ]]; then
        echo "Error: Please provide a question or query" >&2
        show_help >&2
        exit 1
    fi
    
    send_request "$query" "$model" "$no_format"
}

main "$@"