#!/bin/bash

set -e

CLAUDE_API_URL="https://api.anthropic.com/v1/messages"
CONFIG_FILE="$HOME/.claude-cli-config"
HISTORY_FILE="$HOME/.claude-cli-history"
DEFAULT_MODEL="claude-3-5-haiku-latest"
VERSION="v1.1.0"

show_help() {
    cat << EOF
Usage: claude-cli [OPTIONS] "your question"

A simple CLI tool for interacting with Anthropic Claude API.

OPTIONS:
    -h, --help            Show this help message
    -k, --key KEY         Set API key (saves to config file)
    -m, --model MODEL     Model to use for this request
    -d, --default MODEL   Set default model (saves to config file)
    --show-model          Show currently configured default model
    --list-models         List all available Anthropic API models
    --no-format           Disable markdown formatting in output
    --context-window      Force enable conversation history for this request only
    --toggle-context      Toggle conversation history on/off permanently (saves to config)
    --restart-chat        Clear conversation history and start fresh

EXAMPLES:
    claude-cli "What is the weather like today?"
    claude-cli -k YOUR_API_KEY
    claude-cli -m claude-3-haiku-20240307 "Quick question"
    claude-cli -d claude-sonnet-4-0
    claude-cli --show-model
    claude-cli --list-models
    claude-cli --no-format
    claude-cli --context-window "Continue our previous conversation"
    claude-cli --toggle-context
    claude-cli --restart-chat

SETUP:
    1. Get your API key from https://console.anthropic.com/
    2. Run: claude-cli -k YOUR_API_KEY
    3. Optionally set default model: claude-cli -d MODEL_NAME
    4. Ask questions: claude-cli "Your question here"

Created by Michal Šára (https://michalsara.cz)
Version: $VERSION
EOF
}

save_api_key() {
    local temp_file=$(mktemp)
    
    # Preserve existing default model and context setting if they exist
    if [[ -f "$CONFIG_FILE" ]]; then
        grep "^CLAUDE_DEFAULT_MODEL=" "$CONFIG_FILE" >> "$temp_file" 2>/dev/null || true
        grep "^CLAUDE_CONTEXT_ENABLED=" "$CONFIG_FILE" >> "$temp_file" 2>/dev/null || true
    fi
    
    echo "CLAUDE_API_KEY=$1" >> "$temp_file"
    mv "$temp_file" "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
    echo "API key saved to $CONFIG_FILE"
    exit 0
}

save_default_model() {
    local temp_file=$(mktemp)
    
    # Preserve existing API key and context setting if they exist
    if [[ -f "$CONFIG_FILE" ]]; then
        grep "^CLAUDE_API_KEY=" "$CONFIG_FILE" >> "$temp_file" 2>/dev/null || true
        grep "^CLAUDE_CONTEXT_ENABLED=" "$CONFIG_FILE" >> "$temp_file" 2>/dev/null || true
    fi
    
    echo "CLAUDE_DEFAULT_MODEL=$1" >> "$temp_file"
    mv "$temp_file" "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
    echo "Default model set to $1 and saved to $CONFIG_FILE"
    exit 0
}

save_context_setting() {
    local enabled="$1"
    local temp_file=$(mktemp)
    
    # Preserve existing API key and default model if they exist
    if [[ -f "$CONFIG_FILE" ]]; then
        grep "^CLAUDE_API_KEY=" "$CONFIG_FILE" >> "$temp_file" 2>/dev/null || true
        grep "^CLAUDE_DEFAULT_MODEL=" "$CONFIG_FILE" >> "$temp_file" 2>/dev/null || true
    fi
    
    echo "CLAUDE_CONTEXT_ENABLED=$enabled" >> "$temp_file"
    mv "$temp_file" "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
    
    if [[ "$enabled" == "true" ]]; then
        echo "Context window ENABLED and saved to config"
    else
        echo "Context window DISABLED and saved to config"
    fi
    exit 0
}

load_config() {
    if [[ -f "$CONFIG_FILE" ]]; then
        source "$CONFIG_FILE"
        # Use config default model if set, otherwise use hardcoded default
        if [[ -n "$CLAUDE_DEFAULT_MODEL" ]]; then
            DEFAULT_MODEL="$CLAUDE_DEFAULT_MODEL"
        fi
    fi
}

show_current_model() {
    load_config
    if [[ -n "$CLAUDE_DEFAULT_MODEL" ]]; then
        echo "Currently configured default model: $CLAUDE_DEFAULT_MODEL"
    else
        echo "No default model configured, using built-in default: $DEFAULT_MODEL"
    fi
    exit 0
}

list_available_models() {
    if [[ -z "$CLAUDE_API_KEY" ]]; then
        echo "Error: API key not found. Set it with: claude-cli -k YOUR_API_KEY" >&2
        exit 1
    fi
    
    echo "Fetching available Anthropic API models..."
    echo
    
    local response=$(curl -s -X GET "https://api.anthropic.com/v1/models" \
        -H "x-api-key: $CLAUDE_API_KEY" \
        -H "anthropic-version: 2023-06-01")
    
    if echo "$response" | jq -e '.error' &> /dev/null; then
        echo "Error: $(echo "$response" | jq -r '.error.message')" >&2
        exit 1
    fi
    
    # Check if the response contains models data
    if echo "$response" | jq -e '.data' &> /dev/null; then
        echo "Available models:"
        echo "$response" | jq -r '.data[] | "  • \(.id) (\(.created | strftime("%Y-%m-%d")))"' 2>/dev/null || \
        echo "$response" | jq -r '.data[] | "  • \(.id)"'
    else
        echo "Could not retrieve models list. Response:"
        echo "$response" | jq . 2>/dev/null || echo "$response"
    fi
    
    exit 0
}

toggle_context() {
    load_config
    
    # Check current state and toggle it
    if [[ "$CLAUDE_CONTEXT_ENABLED" == "true" ]]; then
        save_context_setting "false"
    else
        save_context_setting "true"
    fi
}

clear_history() {
    if [[ -f "$HISTORY_FILE" ]]; then
        rm "$HISTORY_FILE"
        echo "Conversation history cleared"
    else
        echo "No conversation history found"
    fi
    exit 0
}

save_to_history() {
    local role="$1"
    local content="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Create history file if it doesn't exist
    touch "$HISTORY_FILE"
    chmod 600 "$HISTORY_FILE"
    
    # Append the message to history in compact JSON format (one line per object)
    local entry=$(jq -c -n \
        --arg role "$role" \
        --arg content "$content" \
        --arg timestamp "$timestamp" \
        '{
            "role": $role,
            "content": $content,
            "timestamp": $timestamp
        }')
    
    echo "$entry" >> "$HISTORY_FILE"
}

load_history() {
    if [[ ! -f "$HISTORY_FILE" ]]; then
        echo "[]"
        return
    fi
    
    # Read history and convert to Claude API format
    # Keep only the last 20 messages to manage token usage efficiently
    local messages="[]"
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and process single-line JSON objects
        if [[ -n "$line" && "$line" =~ ^\{.*\}$ ]]; then
            # Validate JSON line first
            if echo "$line" | jq empty 2>/dev/null; then
                local role=$(echo "$line" | jq -r '.role' 2>/dev/null)
                local content=$(echo "$line" | jq -r '.content' 2>/dev/null)
                
                if [[ "$role" != "null" && "$content" != "null" && -n "$role" && -n "$content" ]]; then
                    # Use jq to properly escape the content
                    messages=$(echo "$messages" | jq --arg role "$role" --arg content "$content" '. += [{"role": $role, "content": $content}]')
                fi
            fi
        fi
    done < "$HISTORY_FILE"
    
    # Keep only the last 20 messages for token efficiency
    echo "$messages" | jq '.[-20:]'
}

format_markdown() {
    local text="$1"
    local no_format="$2"
    
    if [[ "$no_format" == "true" ]]; then
        echo "$text"
        return
    fi
    
    # Try to use glow if available for better markdown rendering
    if command -v glow &> /dev/null; then
        echo "$text" | glow -s auto -w 80
        return
    fi
    
    # Define colors using printf with ANSI codes for better compatibility
    local RED=$(printf '\033[31m')
    local GREEN=$(printf '\033[32m')
    local YELLOW=$(printf '\033[33m')
    local BLUE=$(printf '\033[34m')
    local MAGENTA=$(printf '\033[35m')
    local CYAN=$(printf '\033[36m')
    local WHITE=$(printf '\033[37m')
    local BOLD=$(printf '\033[1m')
    local DIM=$(printf '\033[2m')
    local ITALIC=$(printf '\033[3m')
    local UNDERLINE=$(printf '\033[4m')
    local RESET=$(printf '\033[0m')
    local BG_BLACK=$(printf '\033[40m')
    local BG_GRAY=$(printf '\033[100m')
    
    # Process text line by line to maintain structure
    echo "$text" | while IFS= read -r line || [[ -n "$line" ]]; do
        processed_line="$line"
        
        # Headers with different colors and styles
        if [[ $processed_line =~ ^####[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n" "$WHITE" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
        elif [[ $processed_line =~ ^###[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n" "$CYAN" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
        elif [[ $processed_line =~ ^##[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n" "$BLUE" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
        elif [[ $processed_line =~ ^#[[:space:]](.*)$ ]]; then
            printf "%s%s▶ %s%s\n\n" "$MAGENTA" "$BOLD" "${BASH_REMATCH[1]}" "$RESET"
            
        # Code blocks (triple backticks)
        elif [[ $processed_line =~ ^\`\`\`(.*)$ ]]; then
            if [[ -n "${BASH_REMATCH[1]}" ]]; then
                printf "%s%s┌─ %s ─%s\n" "$GREEN" "$DIM" "${BASH_REMATCH[1]}" "$RESET"
            else
                printf "%s%s└────────%s\n" "$GREEN" "$DIM" "$RESET"
            fi
            
        # Horizontal rule
        elif [[ $processed_line =~ ^---+$ ]] || [[ $processed_line =~ ^\*\*\*+$ ]]; then
            printf "%s%s────────────────────────────────────────%s\n" "$DIM" "$WHITE" "$RESET"
            
        # Blockquotes
        elif [[ $processed_line =~ ^\>[[:space:]]*(.*)$ ]]; then
            printf "%s%s▌ %s%s%s\n" "$YELLOW" "$DIM" "$ITALIC" "${BASH_REMATCH[1]}" "$RESET"
            
        # Lists (unordered)
        elif [[ $processed_line =~ ^([[:space:]]*)[-*+][[:space:]](.*)$ ]]; then
            local indent="${BASH_REMATCH[1]}"
            local content="${BASH_REMATCH[2]}"
            printf "%s%s•%s %s\n" "$indent" "$CYAN" "$RESET" "$content"
            
        # Lists (ordered)
        elif [[ $processed_line =~ ^[[:space:]]*[0-9]+\.[[:space:]](.*)$ ]]; then
            local indent=""
            local number=""
            if [[ $processed_line =~ ^([[:space:]]*)([0-9]+)\.[[:space:]](.*)$ ]]; then
                indent="${BASH_REMATCH[1]}"
                number="${BASH_REMATCH[2]}"
                content="${BASH_REMATCH[3]}"
                printf "%s%s%s%s.%s %s\n" "$indent" "$BLUE" "$BOLD" "$number" "$RESET" "$content"
            fi
            
        else
            # Process inline formatting
            
            # Bold text **text** and __text__
            processed_line=$(echo "$processed_line" | sed "s/\*\*\([^*]*\)\*\*/${BOLD}\1${RESET}/g")
            processed_line=$(echo "$processed_line" | sed "s/__\([^_]*\)__/${BOLD}\1${RESET}/g")
            
            # Italic text *text* and _text_ (avoid conflict with bold)
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)\*\([^*][^*]*\)\*\([^*_]\)/\1${ITALIC}\2${RESET}\3/g")
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)_\([^_][^_]*\)_\([^*_]\)/\1${ITALIC}\2${RESET}\3/g")
            processed_line=$(echo "$processed_line" | sed "s/^\*\([^*][^*]*\)\*\([^*_]\)/${ITALIC}\1${RESET}\2/g")
            processed_line=$(echo "$processed_line" | sed "s/^_\([^_][^_]*\)_\([^*_]\)/${ITALIC}\1${RESET}\2/g")
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)\*\([^*][^*]*\)\*$/${ITALIC}\2${RESET}/g")
            processed_line=$(echo "$processed_line" | sed "s/\([^*_]\)_\([^_][^_]*\)_$/${ITALIC}\2${RESET}/g")
            
            # Strikethrough ~~text~~
            processed_line=$(echo "$processed_line" | sed "s/~~\([^~]*\)~~/${DIM}\1${RESET}/g")
            
            # Inline code `code`
            processed_line=$(echo "$processed_line" | sed "s/\`\([^\`]*\)\`/${BG_GRAY}${WHITE} \1 ${RESET}/g")
            
            # Links [text](url)
            processed_line=$(echo "$processed_line" | sed "s/\[\([^]]*\)\](\([^)]*\))/${UNDERLINE}${BLUE}\1${RESET}${DIM} (\2)${RESET}/g")
            
            # Simple URLs http(s)://...
            processed_line=$(echo "$processed_line" | sed "s/\(https\?:\/\/[^[:space:]]*\)/${UNDERLINE}${BLUE}\1${RESET}/g")
            
            printf "%s\n" "$processed_line"
        fi
    done
}

check_dependencies() {
    if ! command -v curl &> /dev/null; then
        echo "Error: curl is required but not installed." >&2
        exit 1
    fi
    
    if ! command -v jq &> /dev/null; then
        echo "Error: jq is required but not installed." >&2
        echo "Install with: brew install jq (macOS) or apt-get install jq (Ubuntu)" >&2
        exit 1
    fi
}

send_request() {
    local query="$1"
    local model="${2:-$DEFAULT_MODEL}"
    local no_format="$3"
    local use_context="${4:-false}"
    
    if [[ -z "$CLAUDE_API_KEY" ]]; then
        echo "Error: API key not found. Set it with: claude-cli -k YOUR_API_KEY" >&2
        exit 1
    fi
    
    local messages
    if [[ "$use_context" == "true" ]]; then
        # Load existing history and add new user message
        messages=$(load_history)
        messages=$(echo "$messages" | jq ". += [{\"role\": \"user\", \"content\": \"$query\"}]")
        
        # Save user message to history
        save_to_history "user" "$query"
    else
        # Single message without context
        messages='[{"role": "user", "content": "'"$query"'"}]'
    fi
    
    local json_payload=$(jq -n \
        --arg model "$model" \
        --argjson messages "$messages" \
        '{
            "model": $model,
            "max_tokens": 1024,
            "messages": $messages
        }')
    
    local response=$(curl -s -X POST "$CLAUDE_API_URL" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $CLAUDE_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "$json_payload")
    
    if echo "$response" | jq -e '.error' &> /dev/null; then
        echo "Error: $(echo "$response" | jq -r '.error.message')" >&2
        exit 1
    fi
    
    local content=$(echo "$response" | jq -r '.content[0].text')
    
    # Save assistant response to history if using context
    if [[ "$use_context" == "true" ]]; then
        save_to_history "assistant" "$content"
    fi
    
    format_markdown "$content" "$no_format"
}

main() {
    check_dependencies
    load_config
    
    local model="$DEFAULT_MODEL"
    local query=""
    local no_format="false"
    local use_context="${CLAUDE_CONTEXT_ENABLED:-false}"
    local context_override="false"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -k|--key)
                if [[ -z "$2" ]]; then
                    echo "Error: API key required after -k/--key" >&2
                    exit 1
                fi
                save_api_key "$2"
                ;;
            -m|--model)
                if [[ -z "$2" ]]; then
                    echo "Error: Model name required after -m/--model" >&2
                    exit 1
                fi
                model="$2"
                shift 2
                ;;
            -d|--default)
                if [[ -z "$2" ]]; then
                    echo "Error: Model name required after -d/--default" >&2
                    exit 1
                fi
                save_default_model "$2"
                ;;
            --show-model)
                show_current_model
                ;;
            --list-models)
                list_available_models
                ;;
            --no-format)
                no_format="true"
                shift
                ;;
            --context-window)
                use_context="true"
                context_override="true"
                shift
                ;;
            --toggle-context)
                toggle_context
                ;;
            --restart-chat)
                clear_history
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                show_help >&2
                exit 1
                ;;
            *)
                query="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$query" ]]; then
        echo "Error: Please provide a question or query" >&2
        show_help >&2
        exit 1
    fi
    
    send_request "$query" "$model" "$no_format" "$use_context"
}

main "$@"